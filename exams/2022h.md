# Eksamen i INF122 Høsten 2022

## ℹ️ Velkommen

[cite\_start]Velkommen til eksamen i INF122[cite: 1, 2, 4]. [cite\_start]Denne eksamenen teller **70%** av sluttkarakteren[cite: 4].

- [cite\_start]**Antall oppgaver:** 7, hvorav 2 flervalgsoppgaver og 5 programmeringsoppgaver[cite: 5].
- Det blir ikke trukket poeng for uriktige svar på flervalgsoppgavene. [cite\_start]Så det lønner seg alltid å svare[cite: 6].
- [cite\_start]Noen av programmeringsoppgavene er delt opp i deloppgaver[cite: 7]. [cite\_start]Alle deloppgaver skal svares på i samme kodeboks, nederst på oppgavesiden[cite: 7].
- [cite\_start]Marker hver deloppgave tydelig[cite: 8].
- Noen deloppgaver ber deg om en beregning eller forklaring. [cite\_start]Disse skriver du også i kodeboksen[cite: 9].
- Bruk tiden godt\! [cite\_start]Dersom du sitter fast på en oppgave kan du fortsette med de andre oppgavene og komme tilbake til den oppgaven senere[cite: 10].
- [cite\_start]Dersom svaret ikke er helt riktig, kan du fortsatt få poeng for en delvis løsning[cite: 11].
- [cite\_start]Lykke til\! [cite: 12]

---

## 1\. Verdier (Maks poeng: 12)

[cite\_start]**a) Hva er verdien av uttrykket:** `sum [1..4]` [cite: 15]

[cite\_start]**b) Hva er verdien av uttrykket:** `div 10 3` [cite: 18]

[cite\_start]**c) Hva er verdien til uttrykket:** `Map.lookup "foo" (Map.fromList [("foo", 4), ("bar",5)])` [cite: 19]
Velg ett alternativ:

- [cite\_start]☐ Nothing [cite: 22]
- [cite\_start]☐ **Just 4** [cite: 23]
- [cite\_start]☐ 04 [cite: 25]
- [cite\_start]☐ 05 [cite: 26]

[cite\_start]**d) Hva er typen til `length` fra standardbiblioteket?** [cite: 27]
Velg ett alternativ:

- [cite\_start]☐ `[a] -> Integer` [cite: 29]
- [cite\_start]☐ **`[a] -> Int`** [cite: 30]
- [cite\_start]☐ `[Integer]` [cite: 33]
- [cite\_start]☐ `Int -> [a]` [cite: 34]

[cite\_start]**e) Hva er verdien til uttrykket:** `length $[x|x<-[1..10]$, odd x]` [cite: 35]
Velg ett alternativ:

- [cite\_start]☐ `[1,2,3,4,5,6,7,8,9,10]` [cite: 40]
- [cite\_start]☐ `[1,3,5,7,9]` [cite: 41]
- [cite\_start]☐ **5** [cite: 42]
- [cite\_start]☐ 00 [cite: 43]

[cite\_start]**f) Hva er verdien til uttrykket:** `map head (words "rolling on floor laughing")` [cite: 46]
[cite\_start]Husk at `words :: String -> [String]`[cite: 46].
Velg ett alternativ:

- [cite\_start]☐ 'r' [cite: 48]
- [cite\_start]☐ "rolling" [cite: 50]
- [cite\_start]☐ **"rofl"** [cite: 51]
- [cite\_start]☐ O'r' [cite: 49]

---

## 2\. Typer og kinds (Maks poeng: 12)

[cite\_start]**a) Hva er riktig type til uttrykket `Just (Right "Haskell")`?** [cite: 56]
Velg ett alternativ:

- [cite\_start]☐ **`Maybe (Either a String)`** [cite: 61]
- [cite\_start]☐ `Maybe (Right String)` [cite: 62]
- [cite\_start]☐ `Maybe String` [cite: 63]
- [cite\_start]☐ `Either (Maybe String) a` [cite: 64]

[cite\_start]**b) Hva er riktig type til uttrykket `(\x -> x ++ "world")`?** [cite: 66]
Velg ett alternativ:

- [cite\_start]☐ `String` [cite: 72]
- [cite\_start]☐ **`String -> String`** [cite: 73]
- [cite\_start]☐ `String -> String -> String` [cite: 74]
- [cite\_start]☐ `Integer -> String` [cite: 75]

[cite\_start]**c) Hvilken kind har `Maybe`?** [cite: 76]

- (Antatt riktig svar: $\star \rightarrow \star$)
- [cite\_start](Andre alternativer inkluderer: Monad [cite: 83][cite\_start], Funktor [cite: 85])

[cite\_start]**d) Hvilken kind har `Either`?** [cite: 86]

- (Antatt riktig svar: $\star \rightarrow \star \rightarrow \star$)
- [cite\_start](Andre alternativer inkluderer: Functor [cite: 89][cite\_start], Monad [cite: 92])

[cite\_start]**e) Hvilke av typene er riktige typinger av funksjonen nedenfor?** [cite: 93]
[cite\_start]$$f~x~y=x==y+1$$ [cite: 94]
Velg de to riktige typingene:

- [cite\_start]☐ `f :: String -> String -> Bool` [cite: 98]
- [cite\_start]☐ `f :: (Int->Int)->Bool` [cite: 99]
- [cite\_start]☐ **`f :: (Eq a, Num a) => a -> a -> Bool`** [cite: 100]
- [cite\_start]☐ **`f :: Integer -> Integer -> Bool`** [cite: 102]
- [cite\_start]☐ `f :: a -> a -> Bool` [cite: 104]

[cite\_start]**f) Hvilke av typene er riktige typinger av funksjonen nedenfor?** [cite: 105]
[cite\_start]$$f~g~x=map(g~x)$$ [cite: 106]
Velg de to riktige typingene:

- [cite\_start]☐ **`f :: (a -> a -> b) -> a -> [a] -> [b]`** [cite: 112] (Basert på $map (g~x)$, hvor $g~x$ er en funksjon $a \rightarrow b$)
- [cite\_start]☐ `f :: (a -> a) -> [a] -> [a]` [cite: 113]
- [cite\_start]☐ `f :: (a -> a -> a) -> a -> [a] -> [a]` [cite: 114]
- [cite\_start]☐ `f :: a -> b -> [a] -> [b]` [cite: 115]
- [cite\_start]☐ **(Implisitt riktig basert på typen av $g~x$)** `f :: (a -> b) -> [a] -> [b]` [cite: 116] (Her er $g~x$ i uttrykket $map (g~x)[cite_start]$ den funksjonen som brukes i $map$, og den har type $a \rightarrow b$. Hvis $g$ har type $a \rightarrow (a \rightarrow b)$ og $x$ har type $a$, blir $g~x$ av type $a \rightarrow b$. Dermed har $f$ type $(a \rightarrow (a \rightarrow b)) \rightarrow a \rightarrow [a] \rightarrow [b]$[cite: 112].)

---

## 3\. Enkel IO (Maks poeng: 8)

[cite\_start]I denne oppgaven skal du vise at du behersker enkel IO og `do`-notasjon[cite: 122].

[cite\_start]**Oppgave:** Skriv en `main :: IO ()` verdi som spør brukeren om fornavnet sitt og svarer med å hilse brukeren med navnet skrevet baklengs[cite: 123].

[cite\_start]Husk å korrigere slik at navnet får stor forbokstav[cite: 124].

[cite\_start]_Eksempelkjøring av programmet:_ [cite: 125]

```
[cite_start]Hva heter du til fornavn? [cite: 126]
[cite_start]Kari [cite: 127]
[cite_start]Hei, Irak! [cite: 128]
```

[cite\_start]Funksjoner du kan ha bruk for: [cite: 129]

- [cite\_start]`toUpper :: Char -> Char` [cite: 130]
- [cite\_start]`toLower :: Char -> Char` [cite: 131]
- [cite\_start]`head :: [a] -> a` [cite: 132]
- [cite\_start]`tail :: [a] -> [a]` [cite: 133]
- [cite\_start]`init :: [a] -> [a]` (`init` fjerner siste element i en liste) [cite: 134]
- [cite\_start]`last :: [a] -> a` [cite: 134]
- [cite\_start]`getLine :: IO String` [cite: 135]
- [cite\_start]`putStrLn :: String -> IO ()` [cite: 135]

Svar her:

```haskell
-- Svar på Oppgave 3
```

---

## 4\. Listefunksjoner (Maks poeng: 14)

[cite\_start]I denne oppgaven skal du vise at du mestrer behandling av lister i Haskell[cite: 143].

[cite\_start]**a) Skriv en funksjon `sumOfSquares :: [Integer] -> Integer` ved hjelp av listekomprehensjon.** [cite: 144]
[cite\_start]Funksjonen tar inn en liste med tall og regner ut summen av kvadratene av tallene i listen[cite: 145]. [cite\_start]For eksempel: `sumOfSquares [1,2,3] = 1^2 + 2^2 + 3^2 = 14`[cite: 146].

[cite\_start]**b) Skriv samme funksjon som i a) men erstatt listekomprehensjonen med bruk av funksjonen `map`.** [cite: 147]

[cite\_start]**c) Skriv en funksjon `duplicate :: [a] -> [a]` som dupliserer hvert element i en liste.** [cite: 148] [cite\_start]For eksempel: `duplicate "Hei" = "HHeeii"`[cite: 148].
[cite\_start]Velg selv hvilken fremgangsmåte du vil bruke[cite: 149].

[cite\_start]**d) Regn ut verdien av uttrykket: `f "abcdefg"` hvor `f` er funksjonen nedenfor.** [cite: 150]
[cite\_start]Du behøver ikke gi hele utregningen i denne deloppgaven, kun svaret[cite: 151].
[cite\_start]$$f = map snd . filter (odd . fst) . zip [0..]$$ [cite: 152]

Svar på alle deloppgaver i denne kodeboksen:

```haskell
-- Svar på Oppgave 4
```

---

## 5\. `product` (Maks poeng: 8)

I denne oppgaven skal du vise at du kan bruke definisjonen av en rekursivt definert funksjon til å vise at den har en gitt egenskap. [cite\_start]Samt vise at du mestert `fold`[cite: 156, 157].

[cite\_start]Husk at vi definerer funksjonen `product` rekursivt som følger: [cite: 158]

```haskell
[cite_start]product :: [Integer] -> Integer [cite: 159]
[cite_start]product [] = 1 [cite: 160]
[cite_start]product (x:xs) = x * (product xs) [cite: 161]
```

[cite\_start]**a) Vis ved utregning at for hvert heltall `a`, `b` og `c` så holder følgende:** [cite: 162]
[cite\_start]$$\text{product } [a,b,c] = a*b*c$$ [cite: 163]

[cite\_start]**b) Gi en alternativ definisjon av `product` som bruker `foldr` istedet for rekursjon.** [cite: 164]
[cite\_start]Husk at `foldr` har typen $$(a \rightarrow b \rightarrow b) \rightarrow b \rightarrow [a] \rightarrow b$$ [cite: 165]

Svar på alle deloppgavene i denne kodeboksen:

```haskell
-- Svar på Oppgave 5
```

---

## 6\. `hasLength` (Maks poeng: 10)

[cite\_start]I denne oppgaven skal vi se på to ulike måter å sjekke om en liste har en gitt lengde[cite: 172].

[cite\_start]Husk at lengdefunksjonen, `length`, er definert ved rekursjon som følger: [cite: 173]

```haskell
[cite_start]length :: [a] -> Int [cite: 174]
[cite_start]length [] = 0 [cite: 175]
[cite_start]length (x:xs) = 1 + length xs [cite: 176]
```

Vi definerer så funksjonen:
[cite\_start]$$\text{hasLength} :: \text{Int} \rightarrow [a] \rightarrow \text{Bool}$$ [cite: 178]
[cite\_start]$$\text{hasLength } n \text{ list} = \text{length list} == n$$ [cite: 179]

[cite\_start]**a) Hva får vi hvis vi evaluerer `hasLength 2 [1,2,3]`?** Du behøver ikke gi utregningen, bare svaret[cite: 180].

[cite\_start]**b) Forklar hva som skjer dersom man prøver å evaluere (i GHCi for eksempel) uttrykket `hasLength 2 [1,2..]`**[cite: 181].

[cite\_start]**c) Skriv en alternativ implementasjon av `hasLength` slik at `hasLength 2 [1,2..]` evaluerer til `False`.** [cite: 182]
[cite\_start]_Hint:_ Bruk rekursjon og `patternmatching`[cite: 183].

[cite\_start]**d) Skriv en utregning som viser at for din `hasLength` så evaluerer `hasLength 2 [1,2..]` til `False`.** [cite: 184]

Skriv ditt svar på alle deloppgavene i denne kodeboksen:

```haskell
-- Svar på Oppgave 6
```

---

## 7\. Records (Maks poeng: 6)

[cite\_start]I denne oppgaven skal vi se på induktive datatyper, `Maps` og rekursjon[cite: 190].

Her er den induktive datastrukturen for `Record`:

```haskell
data Record key value
  [cite_start]= Record (Map key (Either (Record key value) value)) [cite: 220, 221]
```

[cite\_start]Et element i denne strukturen, en record, inneholder et map fra nøkler til enten en underrecord eller en verdi[cite: 222].

[cite\_start]Vi ser på to måter å sette sammen records på: **overfladisk union** (`shallowUnion`) og **dyp union** (`deepUnion`)[cite: 235].

- [cite\_start]**Overfladisk union:** Tar to records og slår de sammen slik at hvis en nøkkel forekommer i en record så tas den med i unionen[cite: 236]. [cite\_start]Dersom en nøkkel forekommer i begge tas kun med verdien eller underrecorden fra den første[cite: 237].
  [cite\_start]$$\text{shallowUnion } x \text{ } y = \{"A":3;"B":\{"C":3\}\}$$ [cite: 243, 244]
- [cite\_start]**Dyp union:** Fungerer som den overfladiske, bortsett fra at dersom en nøkkel forekommer i begge og i begge tilfeller er en underrecord, så slås disse underrecordene sammen med dyp union igjen[cite: 238].
  [cite\_start]$$\text{deepUnion } x \text{ } y = \{"A":3;"B":\{"C":3;"D":3\}\}$$ [cite: 245, 246]

La `x` og `y` være to records:
[cite\_start]$$x = \{"A":3;"B":\{"C":3\}\}$$ [cite: 240] (Merk: Feil i kilden, skal antakelig være: $\{"A":3;"B":\{"C":3\}\}$)
[cite\_start]$$y = \{"A":4;"B":\{"D":3\}\}$$ [cite: 241]

[cite\_start]**a) Skriv en funksjon som beregner den overfladiske unionen av to records.** [cite: 247]

```haskell
shallowUnion :: (Ord key)
  [cite_start]=> Record key value [cite: 248, 249]
  [cite_start]-> Record key value [cite: 250]
  [cite_start]-> Record key value [cite: 251]
```

[cite\_start]**b) Skriv en funksjon som beregner den dype unionen av to records:** [cite: 252]

```haskell
deepUnion :: (Ord key)
  [cite_start]=> Record key value [cite: 253, 254]
  [cite_start]-> Record key value [cite: 255]
  [cite_start]-> Record key value [cite: 256]
```

Svar på alle deloppgavene i denne kodeboksen:

```haskell
-- Svar på Oppgave 7
```

---

Do you want me to try solving any of the tasks, for example, the `shallowUnion` and `deepUnion` in **Oppgave 7**?
