# Eksamen i INF122 Høsten 2023

[cite\_start]Velkommen til eksamen i INF122[cite: 4]. [cite\_start]Denne eksamenen teller **70%** av sluttkarakteren[cite: 4].

- [cite\_start]**Antall oppgaver:** 6, hvorav 2 flervalgsoppgaver og 4 programmeringsoppgaver[cite: 5].
- [cite\_start]Det blir ikke trukket poeng for uriktige svar på flervalgsoppgavene, så det lønner seg alltid å svare[cite: 6].
- [cite\_start]Programmeringsoppgavene er delt opp i deloppgaver[cite: 7]. [cite\_start]Alle deloppgaver skal svares på i samme kodeboks, nederst på oppgavesiden[cite: 7].
- [cite\_start]Marker hver deloppgave tydelig[cite: 8].
- [cite\_start]Noen deloppgaver ber deg om en beregning eller forklaring, og disse skriver du også i kodeboksen[cite: 9].
- [cite\_start]**Tillatte hjelpemidler på eksamen: ingen**[cite: 12].

---

## [cite\_start]1 Verdier og typer (Maks poeng: 14 [cite: 61])

[cite\_start]a) Hva er verdien av uttrykket: `fst (3,"Hei")`[cite: 16]?

[cite\_start]b) Hva er verdien av uttrykket: `tail [1,2,3]`[cite: 17]?

[cite\_start]c) Hva er verdien til uttrykket `length $ zip "Hello" "World"`[cite: 18]?
[cite\_start]Velg ett alternativ [cite: 19] \* [cite\_start]☐ `"HWeolrllod"` [cite: 20] \* [cite\_start]☐ `"HelloWorld"` [cite: 21] \* [cite\_start]☐ $[('H','W'),('e','o'),('l','r'),('l','l'),('o','d')]$ [cite: 22] \* [cite\_start]☐ $10$ [cite: 23] \* [cite\_start]☐ **$5$** [cite: 25]

[cite\_start]d) Hva er typen til uttrykket: `head "123"`[cite: 26]?
[cite\_start]Velg ett alternativ [cite: 27] \* [cite\_start]☐ `Integer` [cite: 28] \* [cite\_start]☐ `[Integer]` [cite: 29] \* [cite\_start]☐ `String` [cite: 32] \* [cite\_start]☐ **`Char`** [cite: 33]

[cite\_start]e) Hva er typen til funksjonen `tail` fra standard biblioteket[cite: 34]?
Velg ett alternativ \* [cite\_start]☐ `a -> [a]` [cite: 36] \* [cite\_start]☐ `[a] -> a` [cite: 37] \* [cite\_start]☐ `a -> a` [cite: 38] \* [cite\_start]☐ **`[a] -> [a]`** [cite: 39]

[cite\_start]f) Hva er verdien av uttrykket `filter (\x -> x == reverse x) (words "tillit renner ikke ned nesen")`[cite: 43]?
[cite\_start]Velg ett alternativ [cite: 44] \* [cite\_start]☐ **`["tillit", "renner","nesen"]`** [cite: 47] \* [cite\_start]☐ `True` [cite: 48] \* [cite\_start]☐ `"tillit"` [cite: 49] \* [cite\_start]☐ `["nesen","ned","ikke", "renner","tillit"]` [cite: 51]

[cite\_start]g) Hvilken type er en gyldig typing av uttrykket `foldr (+) 0`[cite: 52]?
Velg ett alternativ \* [cite\_start]☐ `Integer` [cite: 57] \* [cite\_start]☐ **`[Integer] -> Integer`** [cite: 58] \* [cite\_start]☐ `[Integer]` [cite: 59] \* [cite\_start]☐ `Integer -> Integer` [cite: 60]

---

## [cite\_start]2 Typer, kinds og monader (Maks poeng: 9 [cite: 120])

[cite\_start]a) Hva er en mulig typing av uttrykket `Left (4,"dead")`[cite: 64]?
[cite\_start]Velg ett alternativ [cite: 65] \* [cite\_start]☐ `Maybe (Integer, String)` [cite: 69] \* [cite\_start]☐ **`Either (Integer, String) a`** [cite: 70] \* [cite\_start]☐ `Either Integer String` [cite: 71] \* [cite\_start]☐ `Left (String, Integer)` [cite: 72]

[cite\_start]b) Hva er en mulig typing av uttrykket `\x -> x ++ reverse x`[cite: 73]?
[cite\_start]Velg ett alternativ [cite: 74] \* [cite\_start]☐ `[a] -> a` [cite: 75] \* [cite\_start]☐ `String` [cite: 79] \* [cite\_start]☐ **`[a] -> [a]`** [cite: 80] \* [cite\_start]☐ `Char -> String` [cite: 81]

[cite\_start]c) Hva er en mulig typing av uttrykket `(map map)`[cite: 82]?
[cite\_start]Husk at `map :: (a -> b) -> [a] -> [b]`[cite: 83].
[cite\_start]Velg ett alternativ [cite: 84] \* [cite\_start]☐ **`(a -> b) -> [[a]] -> [[b]]`** [cite: 85] \* [cite\_start]☐ `[a -> b] -> [a] -> [b]` [cite: 86] \* [cite\_start]☐ `[a] -> [b]` [cite: 87] \* [cite\_start]☐ `([a] -> [b]) -> [a] -> [b]` [cite: 88]

[cite\_start]d) Hvilken kind har `Maybe String`[cite: 89]?
[cite\_start]Velg ett alternativ [cite: 93] \* [cite\_start]☐ `Maybe` [cite: 95] \* [cite\_start]☐ **`*`** [cite: 97] \* [cite\_start]☐ `* -> *` [cite: 98] \* [cite\_start]☐ `Functor` [cite: 99]

[cite\_start]e) Hvilken kind har `Either String`[cite: 100]?
[cite\_start]Velg ett alternativ [cite: 101] \* [cite\_start]☐ **`* -> *`** [cite: 102] \* [cite\_start]☐ `*` [cite: 103] \* [cite\_start]☐ `Monad` [cite: 105] \* [cite\_start]☐ `Either` [cite: 107]

[cite\_start]f) Hvilken type har uttrykket `(getLine >>= putStrLn)`[cite: 108]?
Husk at: \* [cite\_start]`(>>=) :: Monad m => m a -> (a -> m b) -> m b` [cite: 109] \* [cite\_start]`getLine :: IO String` [cite: 110] \* [cite\_start]`putStrLn :: String -> IO ()` [cite: 111]

```
[cite_start]Velg ett alternativ [cite: 112]
* [cite_start]☐ **`IO ()`** [cite: 113]
* [cite_start]☐ `IO () -> String` [cite: 114]
* [cite_start]☐ `String -> IO ()` [cite: 118]
* [cite_start]☐ `IO String` [cite: 119]
```

---

## [cite\_start]3 Lister (Maks poeng: 15 [cite: 162])

[cite\_start]I denne oppgaven skal du vise at du behersker behandling av lister i Haskell[cite: 124].
Noen funksjoner fra standardbiblioteket:

- [cite\_start]`length :: [a] -> Int` [cite: 126]
- [cite\_start]`maximum :: (Ord a) => [a] -> a` [cite: 127]
- [cite\_start]`map :: (a -> b) -> [a] -> [b]` [cite: 128]
- [cite\_start]`(++) :: [a] -> [a] -> [a]` [cite: 129]
- [cite\_start]`concat :: [[a]] -> [a]` [cite: 130]
- [cite\_start]`replicate :: Int -> a -> [a]` [cite: 131]
- [cite\_start]`group :: (Eq a) => [a] -> [[a]]` [cite: 132]

[cite\_start]a) Skriv en funksjon `removeMaximum :: (Ord a) => [a] -> [a]` som fjerner (alle forekomster av) det maksimale elementet i en liste[cite: 134]. [cite\_start]Bruk funksjonen `maximum` og listekomprehensjon for å definere `removeMaximum`[cite: 135].
[cite\_start]_Eksempel: `removeMaximum [1,6,2,6,4] = [1,2,4]` [cite: 135]_

[cite\_start]b) Skriv en funksjon `replicateMany :: [(Int,a)] -> [a]` som tar en liste med par hvor første del av paret sier hvor mange ganger den andre delen av paret skal repeteres i resultatet[cite: 139]. [cite\_start]Du kan bruke standardfunksjonen `replicate` i løsningen din[cite: 140].
[cite\_start]_Eksempel: `replicateMany [(3,'a'), (4, 'b'), (1,'c')] = "aaabbbbc"` [cite: 141]_

[cite\_start]c) Funksjonen `group :: (Eq a) => [a] -> [[a]]` er definert ved hjelp av rekursjon[cite: 143, 144]:
`haskell group :: (Eq a) => [a] -> [[a]] [cite_start]group [] = [] [cite: 145] [cite_start]group [a] = [[a]] [cite: 146] group (a:b:as) [cite_start]= let (bs: rest) = group (b:as) [cite: 148] [cite_start]in if (a == b) [cite: 149] [cite_start]then (a:bs):rest [cite: 150] [cite_start]else [a]:bs:rest [cite: 151] `
[cite\_start]Regn ut `group [1,1,2,2,2]`[cite: 152]. [cite\_start]Vis hvordan du har tenkt/regnet[cite: 152].

[cite\_start]d) Skriv en funksjon `dereplicateMany :: (Eq a) => [a] -> [(Int,a)]`, som fungerer som en invers til `replicateMany`[cite: 154].
[cite\_start]_Eksempel: `dereplicateMany "Hellooo" = [(1,'H'),(1,'e'),(2,'l'),(3,'o')]` [cite: 155]_
[cite\_start]_Hint: Bruk `group` funksjonen definert ovenfor[cite: 158]._

[cite\_start]e) Skriv funksjonen `replicateMany :: [(Int,a)] -> [a]` som i b), men denne gangen bruk **do-notasjon for lister** (og `replicate` fra standardbiblioteket)[cite: 160].

---

## [cite\_start]4 Parsing og egendefinerte datatyper (Maks poeng: 10 [cite: 242])

Datatyper for datoer:

```haskell
data Month = January | February | March | April | May | June
           | July | August | September | October | November | December
           [cite_start]deriving (Eq, Show) [cite: 170, 182]

[cite_start]newtype Year = Year Integer deriving (Eq, Show) [cite: 184, 185]

[cite_start]data Date = Date Year Month Integer deriving (Eq, Show) [cite: 187]
```

[cite\_start]Hjelpefunksjoner for skuddår og dager i måneden er gitt[cite: 189, 191, 195]:

[cite\_start]_Parsing_[cite: 205]:

```haskell
[cite_start]newtype Parser a = Parser {runParser :: String -> Maybe (String, a)} [cite: 207, 208]
```

[cite\_start]Du kan anta at instanser for `Functor`, `Applicative`, `Alternative` og `Monad` klassene er gitt for `Parser`[cite: 209]. [cite\_start]Følgende operatorer kan brukes[cite: 211, 215]:

- `fmap` (`<$>`), `(<*>), (*>), (<*), (</>), empty, pure/return`

[cite\_start]Hjelpefunksjonen `keyword :: String -> Parser ()` er gitt[cite: 222].

[cite\_start]a) Skriv en parser `pMonth :: Parser Month` som parser månedene skrevet på engelsk[cite: 219, 220].
[cite\_start]_F. eks. skal den gjøre strengen `"February"` om til `February :: Month`[cite: 220, 221]._

[cite\_start]b) Skriv en parser, `pDate :: Parser Date`, som kun parser **gyldige** datoer på formen `Y-M-D`[cite: 235].
[cite\_start]_Eksempel: `runParser pDate "2023-12-06"` skal returnere `Just ("", Date (Year 2023) December 06)`, men `runParser pDate "2023-02-29"` skal returnere `Nothing`[cite: 236]._
[cite\_start]Du kan ta for gitt en parser `pInteger :: Parser Integer` som parser heltall, samt `keyword` funksjonen[cite: 237]. [cite\_start]Husk at du også kan bruke do-notasjon siden `Parser` er en monade[cite: 238].

---

## 5 Induktive datatyper og invarianter (Maks poeng: 12)

Datatypen `BinTree`:

```haskell
data BinTree a = Empty | Branch (BinTree a) a (BinTree a)
               [cite_start]deriving (Eq, Show) [cite: 245, 246]
```

[cite\_start]a) Skriv en funksjon `sumTree :: (Num a) => BinTree a -> a` som regner summen av all data i treet[cite: 246].
[cite\_start]_Eksempel: Gitt et tre $t$, så er `sumTree t = 28`[cite: 247, 248]._

[cite\_start]b) Skriv en funksjon `maxInTree :: (Ord a) => BinTree a -> Maybe a` som finner det maksimale elementet i treet, dersom det ikke er tomt[cite: 248]. [cite\_start]Du skal ikke anta at inputen til funksjonen er et binært søketre[cite: 249].

[cite\_start]c) Hvilke invarianter må gjelde for at et element av `BinTree` skal være et **binært søketre**[cite: 250]?

[cite\_start]d) Skriv en funksjon `isSearchTree :: (Ord a) => BinTree a -> Bool` som sier om et element av `BinTree` er et søketre eller ei[cite: 251].
[cite\_start]_Eksempler er gitt[cite: 252, 254]._

---

## 6 Permutasjoner (Maks poeng: 10)

[cite\_start]Permutasjoner representeres med assosiasjonslister[cite: 255]:

```haskell
[cite_start]type Permutation a = [(a,a)] [cite: 258]
```

[cite\_start]En permutasjon kan brukes ved å slå opp i listen[cite: 258]:

```haskell
apply :: Permutation a -> a -> a
apply p a = case lookup a p of
              Nothing -> a
              (Just a') -> a'
```

For at en liste med par skal være en gyldig permutasjon, må to krav være oppfylt:

1.  [cite\_start]Hvert element forekommer **kun én gang** som førstekomponent i et par i listen[cite: 259].
2.  [cite\_start]Hvert element som forekommer som andre komponent i et par i listen forekommer også som første komponent for et par i listen[cite: 260].

[cite\_start]a) Skriv en funksjon `allCycles :: (Eq a) => Permutation a -> [[a]]` som finner alle sykler i en permutasjon[cite: 262]. [cite\_start]Funksjonen `allCycles` skal kun gi én representant for hver sykel[cite: 264].
[cite\_start]_Eksempel: `allCycles [(1,2),(4,5),(3,1),(5,4),(2,3)] = [[1,2,3],[4,5]]`[cite: 265]._
[cite\_start]_Hint: Det kan være nødvendig med en hjelpefunksjon[cite: 265]._

---

[cite\_start]Lykke til[cite: 13]\!

Jeg kan hjelpe deg med å se på en spesifikk oppgave, for eksempel å formulere en løsning for en av programmeringsoppgavene. Hvilken oppgave vil du star at jeg ser nærmere på?
